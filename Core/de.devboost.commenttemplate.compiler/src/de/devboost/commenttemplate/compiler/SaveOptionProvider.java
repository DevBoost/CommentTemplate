/*******************************************************************************
 * Copyright (c) 2006-2013
 * Software Technology Group, Dresden University of Technology
 * DevBoost GmbH, Berlin, Amtsgericht Charlottenburg, HRB 140026
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *   Software Technology Group - TU Dresden, Germany;
 *   DevBoost GmbH - Berlin, Germany
 *      - initial API and implementation
 ******************************************************************************/
package de.devboost.commenttemplate.compiler;

import java.util.LinkedHashMap;
import java.util.Map;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.ProjectScope;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.preferences.DefaultScope;
import org.eclipse.core.runtime.preferences.IPreferencesService;
import org.eclipse.core.runtime.preferences.InstanceScope;
import org.eclipse.emf.common.util.URI;
import org.emftext.language.java.resource.java.IJavaOptions;
import org.emftext.language.java.resource.java.util.JavaEclipseProxy;
import org.emftext.language.java.resource.java.util.JavaRuntimeUtil;
import org.osgi.service.prefs.BackingStoreException;
import org.osgi.service.prefs.Preferences;

/**
 * The {@link SaveOptionProvider} determines the options that must be set when
 * saving class generated by CommentTemplate. Currently, the line delimiters to
 * be used are retrieved from the respective Eclipse settings (workspace
 * preferences or project properties).
 */
public class SaveOptionProvider {

	/**
	 * Returns the save options that must be used when saving a resource located
	 * at the given URI.
	 */
	public Map<Object, Object> getSaveOptions(URI targetURI) {
		Map<Object, Object> options = new LinkedHashMap<Object, Object>();
		if (!new JavaRuntimeUtil().isEclipsePlatformRunning()) {
			return options;
		}
		
		IFile compiledFile = new JavaEclipseProxy().getFileForURI(targetURI);
		IProject project = compiledFile.getProject();
		String lineBreak = getLineDelimiter(project);
		options.put(IJavaOptions.LINE_DELIMITER_FOR_PRINTING, lineBreak);
		return options;
	}

	/**
	 * Returns the default line delimiter for the given project. If the project
	 * inherits the line delimiter from the workspace settings, the workspace
	 * line delimiter configuration is returned.
	 */
	private String getLineDelimiter(IProject project) {
		String value = null;
		if (project != null) {
			value = getStoredValue(getPreferences(null));
		}
		if (value == null) {
			IPreferencesService preferencesService = Platform.getPreferencesService();
			if (preferencesService != null) {
				value = getStoredValue(preferencesService.getRootNode().node(DefaultScope.SCOPE));
			}
		}
		return value != null ? value : System.getProperty(Platform.PREF_LINE_SEPARATOR);
	}

	/**
	 * Returns the preferences for the given project.
	 */
	private Preferences getPreferences(IProject project) {
		IPreferencesService preferencesService = Platform.getPreferencesService();
		if (preferencesService == null) {
			return null;
		}
		
		if (project != null) {
			return preferencesService.getRootNode().node(ProjectScope.SCOPE).node(project.getName());
		}

		return preferencesService.getRootNode().node(InstanceScope.SCOPE);
	}

	/**
	 * Returns the value for the line delimiter settings from the given
	 * preferences.
	 */
	private String getStoredValue(Preferences preferences) {
		if (preferences == null) {
			return null;
		}
		
		try {
			// be careful looking up for our node so not to create any nodes as side effect
			if (preferences.nodeExists(Platform.PI_RUNTIME)) {
				return preferences.node(Platform.PI_RUNTIME).get(Platform.PREF_LINE_SEPARATOR, null);
			}
		} catch (BackingStoreException e) {
			// ignore
		}
		return null;
	}
}
